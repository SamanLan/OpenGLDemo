### 绘制顶点
|绘制方法|名称|说明|好处|
|:--|:--|:--|:--|
|glDrawArrays|顶点法|根据传入的定点顺序进行绘制的|
|glDrawElements|索引法|根据索引序列，在顶点序列中找到对应的顶点，并根据绘制的方式，组成相应的图元进行绘制|顶点法拥有的绘制方式，索引法也都有。相对于顶点法在复杂图形的绘制中无法避免大量顶点重复的情况，索引法可以相对顶点法减少很多重复顶点占用的空间。|

**GLES20.glDrawArrays的第一个参数表示绘制方式**

绘制方式有：

|参数|说明|
|:--|:--|
|GL_POINTS|将传入的顶点坐标作为单独的点绘制|
|GL_LINES|将传入的坐标作为单独线条绘制，ABCDEFG六个顶点，绘制AB、CD、EF三条线|
|GL_LINE_STRIP|将传入的顶点作为折线绘制，ABCD四个顶点，绘制AB、BC、CD三条线|
|GL_LINE_LOOP|将传入的顶点作为闭合折线绘制，ABCD四个顶点，绘制AB、BC、CD、DA四条线。|
|GL_TRIANGLES|将传入的顶点作为单独的三角形绘制，ABCDEF绘制ABC,DEF两个三角形|
|GL_TRIANGLE_FAN|将传入的顶点作为扇面绘制，ABCDEF绘制ABC、ACD、ADE、AEF四个三角形|
|GL_TRIANGLE_STRIP|将传入的顶点作为三角条带绘制，ABCDEF绘制ABC,BCD,CDE,DEF四个三角形|
---

### 相机和投影
|名词|解析|
|:--|:--|
|相机位置|就是相机在3D空间里面的坐标点。|
|相机观察方向|表示的是相机镜头的朝向，你可以朝前拍、朝后拍、也可以朝左朝右，或者其他的方向。|
|相机UP方向|可以理解为相机顶端指向的方向。比如你把相机斜着拿着，拍出来的照片就是斜着的，你倒着拿着，拍出来的就是倒着的。|
```
设置相机
Matrix.setLookAtM (float[] rm,      //接收相机变换矩阵
                int rmOffset,       //变换矩阵的起始位置（偏移量）
                float eyeX,float eyeY, float eyeZ,   //相机位置
                float centerX,float centerY,float centerZ,  //观测点位置
                float upX,float upY,float upZ)  //up向量在xyz上的分量
```

|名词|解析|
|:--|:--|
|正交投影|物体呈现出来的大小不会随着其距离视点的远近而发生变化|
|透视投影|物体离视点越远，呈现出来的越小。离视点越近，呈现出来的越大|
```
正交投影
Matrix.orthoM (float[] m,           //接收正交投影的变换矩阵
                int mOffset,        //变换矩阵的起始位置（偏移量）
                float left,         //相对观察点近面的左边距
                float right,        //相对观察点近面的右边距
                float bottom,       //相对观察点近面的下边距
                float top,          //相对观察点近面的上边距
                float near,         //相对观察点近面距离
                float far)          //相对观察点远面距离
```
```
透视投影
Matrix.frustumM (float[] m,         //接收透视投影的变换矩阵
                int mOffset,        //变换矩阵的起始位置（偏移量）
                float left,         //相对观察点近面的左边距
                float right,        //相对观察点近面的右边距
                float bottom,       //相对观察点近面的下边距
                float top,          //相对观察点近面的上边距
                float near,         //相对观察点近面距离
                float far)          //相对观察点远面距离
```
实际上相机设置和投影设置并不是真正的设置，而是通过设置参数，得到一个使用相机后顶点坐标的变换矩阵，和投影下的顶点坐标变换矩阵，我们还需要把矩阵传入给顶点着色器，在顶点着色器中用传入的矩阵乘以坐标的向量，得到实际展示的坐标向量。注意，是矩阵乘以坐标向量，不是坐标向量乘以矩阵，矩阵乘法是不满足交换律的。 为了方便，我们需要将相机矩阵和投影矩阵相乘，得到一个实际的变换矩阵，再传给顶点着色器。矩阵相乘：

```
Matrix.multiplyMM (float[] result, //接收相乘结果
                int resultOffset,  //接收矩阵的起始位置（偏移量）
                float[] lhs,       //左矩阵
                int lhsOffset,     //左矩阵的起始位置（偏移量）
                float[] rhs,       //右矩阵
                int rhsOffset)     //右矩阵的起始位置（偏移量）
```

---
### 着色器语言限定符
|名词|解析|
|:--|:--|
|attribute|一般用于每个顶点都各不相同的量|
|uniform|一般用于对同一组顶点组成的3D物体中各个顶点都相同的量。|
|varying|一般用于从顶点着色器传入到片元着色器的量。|
|const|表示常量|

### 深度测试
（1）什么是深度？ 

深度其实就是该象素点在3d世界中距离摄象机的距离（绘制坐标），深度缓存中存储着每个象素点（绘制在屏幕上的）的深度值！ 
深度值（Z值）越大，则离摄像机越远。 
深度值是存贮在深度缓存里面的，我们用深度缓存的位数来衡量深度缓存的精度。深度缓存位数越高，则精确度越高，目前的显卡一般都可支持16位的Z Buffer，一些高级的显卡已经可以支持32位的Z Buffer，但一般用24位Z Buffer就已经足够了。 

（2）为什么需要深度？ 

在不使用深度测试的时候，如果我们先绘制一个距离较近的物体，再绘制距离较远的物体，则距离远的物体因为后绘制，会把距离近的物体覆盖掉，这样的效果并不是我们所希望的。而有了深度缓冲以后，绘制物体的顺序就不那么重要了，都能按照远近（Z值）正常显示，这很关键。 
实际上，只要存在深度缓冲区，无论是否启用深度测试，OpenGL在像素被绘制时都会尝试将深度数据写入到缓冲区内，除非调用了glDepthMask(GL_FALSE)来禁止写入。这些深度数据除了用于常规的测试外，还可以有一些有趣的用途，比如绘制阴影等等。 

（3）启用深度测试 

使用 glEnable(GL_DEPTH_TEST); 
在默认情况是将需要绘制的新像素的z值与深度缓冲区中对应位置的z值进行比较，如果比深度缓存中的值小，那么用新像素的颜色值更新帧缓存中对应像素的颜色值。 
但是可以使用glDepthFunc(func)来对这种默认测试方式进行修改。 
其中参数func的值可以为GL_NEVER（没有处理）、GL_ALWAYS（处理所有）、GL_LESS（小于）、GL_LEQUAL（小于等于）、GL_EQUAL（等于）、GL_GEQUAL（大于等于）、GL_GREATER（大于）或GL_NOTEQUAL（不等于），其中默认值是GL_LESS。 
一般来将，使用glDepthFunc(GL_LEQUAL);来表达一般物体之间的遮挡关系。 

（4）启用了深度测试，那么这就不适用于同时绘制不透明物体。